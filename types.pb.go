// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.4
// source: types.proto

package wrapping

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// WrapperConfig is the result of a call to SetConfig on a wrapper, returning
// relevant information about the wrapper and its updated configuration
type WrapperConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      map[string]string      `protobuf:"bytes,10,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WrapperConfig) Reset() {
	*x = WrapperConfig{}
	mi := &file_types_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WrapperConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WrapperConfig) ProtoMessage() {}

func (x *WrapperConfig) ProtoReflect() protoreflect.Message {
	mi := &file_types_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WrapperConfig.ProtoReflect.Descriptor instead.
func (*WrapperConfig) Descriptor() ([]byte, []int) {
	return file_types_proto_rawDescGZIP(), []int{0}
}

func (x *WrapperConfig) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// EnvelopeInfo contains the information necessary to perfom encryption or
// decryption in an envelope fashion.
type EnvelopeInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ciphertext is the ciphertext from the envelope.
	Ciphertext []byte `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	// Key is the key used in the envelope.
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// IV is the initialization value used during encryption in the envelope.
	Iv            []byte `protobuf:"bytes,3,opt,name=iv,proto3" json:"iv,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnvelopeInfo) Reset() {
	*x = EnvelopeInfo{}
	mi := &file_types_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnvelopeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnvelopeInfo) ProtoMessage() {}

func (x *EnvelopeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_types_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnvelopeInfo.ProtoReflect.Descriptor instead.
func (*EnvelopeInfo) Descriptor() ([]byte, []int) {
	return file_types_proto_rawDescGZIP(), []int{1}
}

func (x *EnvelopeInfo) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

func (x *EnvelopeInfo) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *EnvelopeInfo) GetIv() []byte {
	if x != nil {
		return x.Iv
	}
	return nil
}

// BlobInfo contains information about the encrypted value along with
// information about the key used to encrypt it.
type BlobInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ciphertext holds the encrypted bytes.
	Ciphertext []byte `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	// IV is the initialization value used during encryption.
	Iv []byte `protobuf:"bytes,2,opt,name=iv,proto3" json:"iv,omitempty"`
	// KeyInfo contains information about the key that was used to create this
	// value.
	KeyInfo       *KeyInfo `protobuf:"bytes,5,opt,name=key_info,json=keyInfo,proto3" json:"key_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlobInfo) Reset() {
	*x = BlobInfo{}
	mi := &file_types_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlobInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlobInfo) ProtoMessage() {}

func (x *BlobInfo) ProtoReflect() protoreflect.Message {
	mi := &file_types_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlobInfo.ProtoReflect.Descriptor instead.
func (*BlobInfo) Descriptor() ([]byte, []int) {
	return file_types_proto_rawDescGZIP(), []int{2}
}

func (x *BlobInfo) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

func (x *BlobInfo) GetIv() []byte {
	if x != nil {
		return x.Iv
	}
	return nil
}

func (x *BlobInfo) GetKeyInfo() *KeyInfo {
	if x != nil {
		return x.KeyInfo
	}
	return nil
}

// KeyInfo contains information about the key was used to encrypt an entry.
type KeyInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Mechanism is the method used by the wrapper to encrypt and sign the data as
	// defined by the wrapper. (optional)
	Mechanism uint64 `protobuf:"varint,1,opt,name=mechanism,proto3" json:"mechanism,omitempty"`
	// This is an opaque ID used by the wrapper to identify the specific key
	// to use as defined by the wrapper. This could be a version, key label, or
	// something else. (optional)
	KeyId string `protobuf:"bytes,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// This value is used when generating our own data encryption keys and
	// encrypting them using the wrapper. (optional)
	WrappedKey    []byte `protobuf:"bytes,5,opt,name=wrapped_key,json=wrappedKey,proto3" json:"wrapped_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyInfo) Reset() {
	*x = KeyInfo{}
	mi := &file_types_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyInfo) ProtoMessage() {}

func (x *KeyInfo) ProtoReflect() protoreflect.Message {
	mi := &file_types_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyInfo.ProtoReflect.Descriptor instead.
func (*KeyInfo) Descriptor() ([]byte, []int) {
	return file_types_proto_rawDescGZIP(), []int{3}
}

func (x *KeyInfo) GetMechanism() uint64 {
	if x != nil {
		return x.Mechanism
	}
	return 0
}

func (x *KeyInfo) GetKeyId() string {
	if x != nil {
		return x.KeyId
	}
	return ""
}

func (x *KeyInfo) GetWrappedKey() []byte {
	if x != nil {
		return x.WrappedKey
	}
	return nil
}

// Options holds options common to all wrappers.
type Options struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The key ID to specify.
	WithKeyId string `protobuf:"bytes,10,opt,name=with_key_id,json=withKeyId,proto3" json:"with_key_id,omitempty"`
	// The AAD bytes, if any.
	WithAad []byte `protobuf:"bytes,20,opt,name=with_aad,json=withAad,proto3" json:"with_aad,omitempty"`
	// Wrapper-specific configuration to pass along.
	WithConfigMap map[string]string `protobuf:"bytes,30,rep,name=with_config_map,json=withConfigMap,proto3" json:"with_config_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Whether to allow configuration values to be read from the environment.
	WithDisallowEnvVars bool `protobuf:"varint,90,opt,name=with_disallow_env_vars,json=withDisallowEnvVars,proto3" json:"with_disallow_env_vars,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Options) Reset() {
	*x = Options{}
	mi := &file_types_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Options) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Options) ProtoMessage() {}

func (x *Options) ProtoReflect() protoreflect.Message {
	mi := &file_types_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Options.ProtoReflect.Descriptor instead.
func (*Options) Descriptor() ([]byte, []int) {
	return file_types_proto_rawDescGZIP(), []int{4}
}

func (x *Options) GetWithKeyId() string {
	if x != nil {
		return x.WithKeyId
	}
	return ""
}

func (x *Options) GetWithAad() []byte {
	if x != nil {
		return x.WithAad
	}
	return nil
}

func (x *Options) GetWithConfigMap() map[string]string {
	if x != nil {
		return x.WithConfigMap
	}
	return nil
}

func (x *Options) GetWithDisallowEnvVars() bool {
	if x != nil {
		return x.WithDisallowEnvVars
	}
	return false
}

var File_types_proto protoreflect.FileDescriptor

const file_types_proto_rawDesc = "" +
	"\n" +
	"\vtypes.proto\x12\bwrapping\"\x8f\x01\n" +
	"\rWrapperConfig\x12A\n" +
	"\bmetadata\x18\n" +
	" \x03(\v2%.wrapping.WrapperConfig.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"P\n" +
	"\fEnvelopeInfo\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x01 \x01(\fR\n" +
	"ciphertext\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x0e\n" +
	"\x02iv\x18\x03 \x01(\fR\x02iv\"h\n" +
	"\bBlobInfo\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x01 \x01(\fR\n" +
	"ciphertext\x12\x0e\n" +
	"\x02iv\x18\x02 \x01(\fR\x02iv\x12,\n" +
	"\bkey_info\x18\x05 \x01(\v2\x11.wrapping.KeyInfoR\akeyInfo\"_\n" +
	"\aKeyInfo\x12\x1c\n" +
	"\tmechanism\x18\x01 \x01(\x04R\tmechanism\x12\x15\n" +
	"\x06key_id\x18\x03 \x01(\tR\x05keyId\x12\x1f\n" +
	"\vwrapped_key\x18\x05 \x01(\fR\n" +
	"wrappedKey\"\x89\x02\n" +
	"\aOptions\x12\x1e\n" +
	"\vwith_key_id\x18\n" +
	" \x01(\tR\twithKeyId\x12\x19\n" +
	"\bwith_aad\x18\x14 \x01(\fR\awithAad\x12L\n" +
	"\x0fwith_config_map\x18\x1e \x03(\v2$.wrapping.Options.WithConfigMapEntryR\rwithConfigMap\x123\n" +
	"\x16with_disallow_env_vars\x18Z \x01(\bR\x13withDisallowEnvVars\x1a@\n" +
	"\x12WithConfigMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B0Z.github.com/openbao/go-kms-wrapping/v2;wrappingb\x06proto3"

var (
	file_types_proto_rawDescOnce sync.Once
	file_types_proto_rawDescData []byte
)

func file_types_proto_rawDescGZIP() []byte {
	file_types_proto_rawDescOnce.Do(func() {
		file_types_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_types_proto_rawDesc), len(file_types_proto_rawDesc)))
	})
	return file_types_proto_rawDescData
}

var file_types_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_types_proto_goTypes = []any{
	(*WrapperConfig)(nil), // 0: wrapping.WrapperConfig
	(*EnvelopeInfo)(nil),  // 1: wrapping.EnvelopeInfo
	(*BlobInfo)(nil),      // 2: wrapping.BlobInfo
	(*KeyInfo)(nil),       // 3: wrapping.KeyInfo
	(*Options)(nil),       // 4: wrapping.Options
	nil,                   // 5: wrapping.WrapperConfig.MetadataEntry
	nil,                   // 6: wrapping.Options.WithConfigMapEntry
}
var file_types_proto_depIdxs = []int32{
	5, // 0: wrapping.WrapperConfig.metadata:type_name -> wrapping.WrapperConfig.MetadataEntry
	3, // 1: wrapping.BlobInfo.key_info:type_name -> wrapping.KeyInfo
	6, // 2: wrapping.Options.with_config_map:type_name -> wrapping.Options.WithConfigMapEntry
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_types_proto_init() }
func file_types_proto_init() {
	if File_types_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_types_proto_rawDesc), len(file_types_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_types_proto_goTypes,
		DependencyIndexes: file_types_proto_depIdxs,
		MessageInfos:      file_types_proto_msgTypes,
	}.Build()
	File_types_proto = out.File
	file_types_proto_goTypes = nil
	file_types_proto_depIdxs = nil
}
